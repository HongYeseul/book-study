# chap1.자바8, 9, 10, 11: 무슨일이 일어나고 있는가?

- 자바가 거듭 변화하는 이유
- 컴퓨팅 환경의 변화
- 자바에 부여되는 시대적 변화 요구
- 자바 8과 자바 9의 새로운 핵심 소개

## 1.1 역사의 흐름은 무엇인가?

자바 역사를 통틀어 가장 큰 변화가 자바 8에서 일어닜디. 예를 들어 다음은 사과 목록을 무게순으로 정렬하는 고전적 코드다.

``` java
Collections.sort(inventory, new Comparator<Apple>() {
    public int compare(Apple a1, Apple a2) {
        return a1.getWeight().compareTo(a2.getWeight());
    }
});
```

자바 8을 이용하면 자연어에 더 가깝게 간단한 방식으로 코드를 구현할 수 있다.
``` java
inventory.sort(comparing(Apple::getWeight));
```

멀티코어 CPU 대중화와 같은 하드웨어적인 변화도 자바 8에 영향을 미쳤다. 이전까지의 대부분 자바 프로그램은 코어 중 하나만을 사용했다. 자바는 이러한 병렬 실행 환경을 쉽게 관리하고 에러가 덜 발생하는 방향으로 진화하려 노력했다.
자바 8에서는 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법을 제공한다.

<자바 8에서 제공하는 새로운 기술>
- 스트림 API
- 메서드에 코드를 전달하는 기법
- 인터페이스의 디폴트 메서드

자바 9에서는 리액티브 프로그래밍이라는 병렬 실행 기법을 지원한다.

각 절에서 다루는 내용은 다음과 같다.

- 1.1절: 자바가 멀티코어 병렬성(기존의 자바에서 부족했던 특성)을 더 쉽게 이용할 수 있도록 진화하는 과정과 관련 개념을 설명한다.
- 1.2절: 자바 8에서 제공하는 코드를 메서드로 전달하는 기법이 어떻게 강력한 새로운 프로그래밍 도구가 될 수 있는지 설명한다.
- 1.3절: 스트림 API(병렬형 데이터를 표현하고 이들 데이터를 병렬로 처리할 수 있음을 유연하게 보여주는)가 어째서 강력하고 새로운 프로그래밍 도구인지 설명한다.
- 1.4절: 디폴트 메서드라는 새로운 자바 8의 기능을 인터페이스, 라이브러리의 간결성 유지 및 재컴파일을 줄이는 데 어떻게 활용할 수 있는지 설명한다.
- 1.5절: JVM을 구성하는 자바 및 기타 언어에서 함수형 프로그래밍이라는 존재가 어떤 영향을 미치는지 제시한다.

요약하자면 1장은 이 책의 나머지 장을 살펴볼 수 있도록 밑거름을 제공한다.

## 1.2 왜 아직도 자바는 변화하는가?

### 1.2.1 프로그래밍 언어 생태계에서 자바의 위치

자바는 처음부터 많은 유용한 라이브러리를 포함하는 잘 설계된 객체지향 언어로 시작했다.

객체지향은 1990년대에 두 가지 이유로 각광받았다. 하나는 캡슐화 덕분에 C에 비해 소프트웨어 엔지니어링적인 문제가 훨씬 적다는 점이고, 다른 하나는 객체지향의 정신적인 모델 덕분에 쉽게 대응할 수 있다는 사실이다. 자바 모델과 자바 코드 애플릿을 안전하게 실행할 수 있었던 초기 브라우저 덕분에 많은 곳을 장악할 수 있었다.

하지만 빅데이터라는 분야가 생기면서 병렬 프로세싱을 활용해야 하는 데 지금까지의 자바로는 충분히 대응할 수 없어서 새로운 자바의 탄생의 이유가 되었다.

지금부터 소개하는 세 개의 절에서는 자바 8 설계의 밑바탕을 이루는 세 가지 프로그래밍 개념을 소개한다.

### 1.2.2 스트림 처리

스트림이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다. 이론적으로 프로그램은 입력 스트림에서 데이터를 한 개씩 읽어 들이며 마찬가지로 출력 스트림으로 데이터를 한 개씩 기록한다. 즉, 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다.

스트림 API의 핵심은 기존에는 한 번에 한 항목을 처리했지만, 자바 8에서는 우리가 하려는 작업을 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있다는 것이다. 또한 스트림 파이프라인을 이용해 여러 CPU 코어에 쉽게 할당할 수 있기 때문에 스레드라는 복잡한 작업을 사용하지 않으면서 병렬성까지 얻을 수 있다.

### 1.2.3 동작 파라미터화로 메서드에 코드 전달하기

자바 8에 추가된 두 번째 프로그램 개념은 코드 일부를 API로 전달하는 기능이다. 메서드를 다른 메서드로 전달하는 것이다. 이러한 기능을 이론적으로 동작 파라미터화(behavior parameterization)라고 부른다. 스트림 API는 연산의 동작을 파라미터화할 수 있는 코드를 전달한다는 사상에 기초하기 때문이다.

### 1.2.4 병렬성과 공유 가변 데이터

세 번째 프로그래밍의 개념은 '병렬성을 공짜로 얻을 수 있다'라는 말에서 시작된다. 병렬성을 얻는 대신 무엇을 포기해야 할까? 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꿔야 한다. 동식에 실행하더라도 안전하게 실행할 수 있어야하기 때문에 공유된 가변 데이터에 접근하지 않아야 한다. 자바 8의 스트림을 이용하면 기존의 자바 스레드 API보다 쉽게 병렬성을 활용할 수 있다. 

### 1.2.5 자바가 진화해야 하는 이유

언어는 하드웨어나 프로그래머 기대의 변화에 부응하는 방향으로 변화해야 한다.

이제 자바 8에 추가된 새로운 개념을 하나씩 자세히 살펴보자.

## 1.3 자바 함수

자바 프로그램에서 조작할 수 있는 것 중에 함수가 추가 되었다. 왜 함수가 필요할까?

프로그래밍 언어의 핵심은 값을 바꾸는 것이다. 이 값은 일급 객체(first-class)라고 부른다. 자바 프로그래밍 언어의 다양한 구조체(메서드, 클래스 같은)가 값의 구조를 표현하는 데 도움이 될 수 있다. 하지만 프로그램을 실행하는 동안 이러한 모든 구조체를 자유롭게 전달할 수는 없다. 이렇게 전달할 수 없는 구조체는 이급 객체(또는 시민-citizens)이다. 

런타임에 메서드를 전달할 수 있다면,(메서드를 일급 객체로 만들면) 프로그래밍에 유용하게 활용할 수 있다. 따라서 자바 8 설계자들은 이급 객체를 일급 객체로 바꿀 수 있는 기능을 추가했다.

### 1.3.1 메서드와 람다를 일급 시민으로

첫 번째로 메서드 참조라는 새로운 자바 8의 기능을 소개한다. 디렉터리에서 모든 숨겨진 파일을 필터링한다고 가정하자. 
``` java
File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
    public boolean accept(File file) {
        return file.isHidden(); // 숨겨진 파일 필터링
    }
})
```

자바 8을 사용하면 다음과 같이 수정할 수 있다.

``` java
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```

자바 8의 메서드 참조(::)를 이용해서 listFiles에 직접 전달할 수 있다. 

**람다 : 익명함수**

직접 메서드를 정의할 수도 있지만, 이용할 수 있는 편리한 클래스나 메서드가 없을 때 람다 문법을 이용하면 더 간결하게 코드를 구현할 수 있다. 예를 들어 ```(int x) -> x + 1```과 같이 사용할 수 있다.

### 1.3.2 코드 넘겨주기 : 예제

``` java
public static boolean isGreenApple(Apple apple) {
    return GREEN.equals(apple.getColor());
}

public static boolean isHeavyApple(Apple apple) {
    return apple.getWeight() > 150;
}

public interface Predicate<T> {
    boolean test(T t);
}

static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple: inventory) {
        if (p.test(apple) {
            result.add(apple);
        })
    }
    return result;
}
```

다음과 같이 사용할 수 있다.

``` java
filterApples(inventory, Apple::isGreenApple);
filterApples(inventory, Apple::isHeavyApple);
```

### 1.3.3. 메서드 전달에서 람다로

메서드를 값으로 전달하는 것은 분명 유용하다. 하지만 한 번만 사용할 메서드를 매번 정의하는 것은 귀찮은 일이다. 자바 8에서는 익명 함수 또는 람다라는 새로운 개념을 이용해 코드를 구현할 수 있다.
``` java
filterApples(inventory, (Apple a) -> GREEN.equals(a.getColor()));
filterApples(inventory, (Apple a) -> a.getWeight() > 150);
```

이 때는 filter와 같은 라이브러리가 있었다.

``` java
static <T> Collection<T> filter(Collection<T> c, Predicate<T> p);
```

filter를 사용하면 다음과 같이 개선할 수 있다.
``` java
filter(inventory, (Apple a) -> a.getWeight() > 150);
```

하지만 병렬성이라는 중요성 때문에 설계자들은 이와 같은 설계를 포기하고 자바 8에서 filter와 비슷한 새로운 스트림 API를 제공한다. 또한 컬렉션과 스트림 간에 변환할 수 있는 메서드(map, reduce 등)도 제공한다.


## 1.4 스트림

거의 모든 자바 애플리케이션은 컬렉션을 만들고 활용한다. 하지만 중첩된 제어 흐름 문장이 많을 경우 코드를 한 번에 이해하기 어렵다. 이 때, 스트림 API를 이용하면 가독성 좋게 개선할 수 있다. 
또한 컬렉션을 이용하여 많은 요소를 가진 목록을 반복한다면 오랜 시간이 걸릴 수 있다. 하지만 스트림 API를 사용했을 경우 서로 다른 CPU 코어에 병렬로 작업을 수행하여 빠르게 처리할 수 있다.

### 1.4.1 멀티스레딩은 어렵다

멀티 스레딩 환경에서 각각의 스레드는 동시에 공유된 데이터에 접근하고, 데이터를 갱신할 수 있다. 스트림 API은 '컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제' 그리고 '멀티코어 활용 어려움'이라는 두 가지 문제를 모두 해결 했다.

라이브러리에서 반복되는 패턴을 제공한다면 좋을 것이라는 아이디어가 변화의 동기가 되었다. 즉, 자주 반복되는 패턴으로 주어진 조건에 따라 데이터를 필터링하거나 데이터를 추출, 그룹화하는 등의 기능이 있다. 이러한 동작들은 쉽게 병렬화가 가능하다.

예를 들어, 두 CPU를 가진 환경에서 리스트를 필터링한다고 가정 해보자.
1. 포크
    - 1번 CPU는 리스트의 앞부분을 처리하고, 2번 CPU는 뒷부분을 처리하도록 요청한다.

2. 필터
    - 각각의 CPU가 자신의 할당량을 처리한다.

3. 결과 합침
    - 하나의 CPU가 두 결과를 정리한다.

컬렉션은 어떻게 데이터를 저장하고 접근할지에 중점을 두는 반면 스트림은 데이터에 어떤 계산을 할 것인지 묘사하는 것에 중점을 둔다.(컬렉션>스트림>병렬처리>다시복원)

자바의 변화 과정에서 자바 8 개발자들이 겪는 어려움 중 하나는 기존 인터페이스의 변경이다. 예를 들어 Collections.sort는 사실 List 인터페이스에 포함되지만 실제로 List로 포함 된 적은 없다. 이론적으로는 Collections.list(list, comparator)가 아니라 list.sort(comparator)를 수행하는 것이 적절하다. 하지만 이전까지는 해당 문제를 해결하는 것은 불가능에 가까웠다. 자바 8에서는 디폴트 메서드로 이 문제를 해결 할 수 있다.

